#!/bin/bash
#
# Ghostty Dock Launcher v1.2 - Project terminals
#
# Usage: ghostty [DIR]  # That's it. Creates launchers in a folder you can drag to dock.
#
set -euo pipefail

readonly VERSION="1.3.0"

# Support custom terminal app via environment variable
# Search order: env var ‚Üí fork ‚Üí official repo ‚Üí nightly ‚Üí production
if [[ -n "${TERMINAL_APP:-}" ]]; then
	readonly TERMINAL_APP
	readonly TERMINAL_APP_SOURCE="env-override"
else
	# Auto-detect Ghostty installation (checks common developer paths)
	if [[ -f "${HOME}/ghostty-fork/zig-out/Ghostty.app/Contents/MacOS/ghostty" ]]; then
		readonly TERMINAL_APP="${HOME}/ghostty-fork/zig-out/Ghostty.app"
		readonly TERMINAL_APP_SOURCE="auto-fork"
	elif [[ -f "${HOME}/ghostty/zig-out/Ghostty.app/Contents/MacOS/ghostty" ]]; then
		readonly TERMINAL_APP="${HOME}/ghostty/zig-out/Ghostty.app"
		readonly TERMINAL_APP_SOURCE="auto-official-repo"
	elif [[ -f "${HOME}/Downloads/Ghostty.app/Contents/MacOS/ghostty" ]]; then
		readonly TERMINAL_APP="${HOME}/Downloads/Ghostty.app"
		readonly TERMINAL_APP_SOURCE="auto-nightly"
	else
		readonly TERMINAL_APP="/Applications/Ghostty.app"
		readonly TERMINAL_APP_SOURCE="auto-production"
	fi
fi

# Support custom binary path or derive from app
if [[ -n "${TERMINAL_BIN:-}" ]]; then
	readonly TERMINAL_BIN
else
	# Auto-detect binary based on app name
	TERMINAL_BIN="${TERMINAL_APP}/Contents/MacOS/$(basename "${TERMINAL_APP}" .app)"
	readonly TERMINAL_BIN
fi

readonly LOG_FILE="$HOME/.ghostty-launcher.log"
readonly MAX_NAME_LENGTH=50

# Simple folder for all launchers - like Utilities
readonly PROJECTS_FOLDER="/Applications/Projects"
readonly PROJECTS_FOLDER_EMOJI="üíº" # Emoji for Projects folder icon (customizable)

# Simple logging
log() {
	[[ -w "$(dirname "$LOG_FILE")" ]] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >>"$LOG_FILE" 2>/dev/null || true
}

# Error handling
die() {
	echo "Error: $1" >&2
	log "ERROR: $1"
	exit 1
}

# Validate project name characters for display names
# Returns 0 if valid, 1 if invalid
# NOTE: This is intentionally MORE permissive than sanitize_name because:
#   - validate_project_name: Used for user-visible display names (allows dots, spaces)
#   - sanitize_name: Used for internal identifiers (removes dots for filesystem safety)
# Example: ".config" passes validation but sanitizes to "config"
validate_project_name() {
	local name="$1"
	# Only allow alphanumeric, dots, dashes, underscores, and spaces
	if [[ "$name" =~ ^[[:alnum:]._[:space:]-]+$ ]]; then
		return 0
	else
		return 1
	fi
}

# Sanitize name for internal identifiers (bundle IDs, config hashes, etc.)
# NOTE: This is intentionally MORE restrictive than validate_project_name:
#   - Removes dots to prevent filesystem path confusion and security issues
#   - Used for internal identifiers, NOT display names
# See validate_project_name for the display name counterpart
sanitize_name() {
	local name="$1"
	# Allow only alphanumeric, dash, underscore (no dots for security)
	name=$(echo "$name" | tr -cd '[:alnum:]-_' | cut -c1-$MAX_NAME_LENGTH)
	[[ -z "$name" ]] && name="unnamed"
	echo "$name"
}

# Generate safe bundle ID
# NOTE: Returns a shared bundle ID for all launchers to enable native macOS notification
# compatibility. Individual launcher routing is handled via URL schemes (see generate_url_scheme).
# The $name parameter is accepted for API consistency but not used in output.
generate_bundle_id() {
	# Parameter accepted for API compatibility, but we use a shared bundle ID
	# to ensure macOS notifications work correctly across all project launchers.
	# Project-specific routing is handled by URL schemes instead.
	echo "com.oste.commandcentral"
}

# Generate URL scheme for notifications
# Sanitizes project name to create valid URL scheme
# Parameters:
#   $1 - name: Project name to convert
# Returns: URL scheme in format "commandcentral-{sanitized-name}"
# Examples:
#   "Icons" ‚Üí "commandcentral-icons"
#   "Universal8" ‚Üí "commandcentral-universal8"
#   "My Project!" ‚Üí "commandcentral-my-project"
#   ".config" ‚Üí "commandcentral-dot-config"
generate_url_scheme() {
	local name="$1"

	# Handle dot-prefixed names (convert .config to dot-config)
	if [[ "$name" == .* ]]; then
		name="dot-${name:1}"
	fi

	# Convert to lowercase
	local scheme_name
	scheme_name=$(echo "$name" | tr '[:upper:]' '[:lower:]')

	# Collapse multiple spaces/underscores to single space first
	scheme_name=$(echo "$scheme_name" | sed 's/[[:space:]_]\+/ /g')

	# Replace spaces with hyphens
	scheme_name=$(echo "$scheme_name" | tr ' ' '-')

	# Remove special characters (keep only alphanumeric and hyphens)
	scheme_name=$(echo "$scheme_name" | tr -cd '[:alnum:]-')

	# Remove multiple consecutive hyphens (safety check)
	scheme_name=$(echo "$scheme_name" | sed 's/-\+/-/g')

	# Remove leading/trailing hyphens
	scheme_name=$(echo "$scheme_name" | sed 's/^-//; s/-$//')

	# Ensure it's not empty
	[[ -z "$scheme_name" ]] && scheme_name="unnamed"

	echo "commandcentral-${scheme_name}"
}

# Check requirements
check_requirements() {
	# Validate terminal app exists and is a valid .app bundle
	if [[ ! -d "$TERMINAL_APP" ]]; then
		die "Terminal app not found: $TERMINAL_APP
To use a custom terminal, set TERMINAL_APP:
  export TERMINAL_APP='/path/to/Terminal.app'"
	fi

	# Validate it's actually an app bundle
	if [[ ! -f "$TERMINAL_APP/Contents/Info.plist" ]]; then
		die "Invalid app bundle: $TERMINAL_APP
The specified path doesn't appear to be a valid macOS application."
	fi

	# Check terminal binary is executable
	if [[ ! -x "$TERMINAL_BIN" ]]; then
		die "Terminal binary not executable: $TERMINAL_BIN
To use a custom binary, set TERMINAL_BIN:
  export TERMINAL_BIN='/path/to/binary'"
	fi

	# Check write permissions to Projects folder
	if [[ -e "$PROJECTS_FOLDER" ]] && [[ ! -w "$PROJECTS_FOLDER" ]]; then
		die "No write permission to: $PROJECTS_FOLDER
To fix this, run:
  sudo chown $USER '$PROJECTS_FOLDER'"
	fi
}

# Extract environment variables from shellEnv object in JSON
extract_shell_env() {
	local file="$1"

	if [[ ! -f "$file" ]]; then
		echo ""
		return
	fi

	# Try jq first (if available), otherwise fall back to Python
	if command -v jq >/dev/null 2>&1; then
		# Use jq for safe JSON parsing
		jq -r '.shellEnv // {} | to_entries[] | "\(.key)=\(.value)"' "$file" 2>/dev/null || echo ""
	else
		# Fall back to Python (always available on macOS)
		# SECURITY: Pass file path as argument to prevent command injection
		python3 -c "
import json
import sys

try:
    with open(sys.argv[1], 'r') as f:
        config = json.load(f)
        env = config.get('shellEnv', {})

        for key, value in env.items():
            # Simple validation - only allow valid env var names
            if key and (key[0].isalpha() or key[0] == '_'):
                # Output key=value pairs
                print(f'{key}={value}')
except:
    pass
" "$file" 2>/dev/null || echo ""
	fi
}

# Validate JSON file and return error message if invalid
validate_json() {
	local file="$1"

	# Check if file exists
	if [[ ! -f "$file" ]]; then
		echo "File not found: $file"
		return 1
	fi

	# Check if file is empty
	if [[ ! -s "$file" ]]; then
		echo "File is empty: $file"
		return 1
	fi

	# Try to parse with jq if available
	if command -v jq >/dev/null 2>&1; then
		local jq_error
		if ! jq_error=$(jq empty "$file" 2>&1); then
			# Parse jq error for common issues
			if echo "$jq_error" | grep -qi "Expected another key-value pair"; then
				echo "Invalid JSON: Trailing comma detected"
			elif echo "$jq_error" | grep -qi "Invalid numeric literal"; then
				echo "Invalid JSON: Missing quotes around string value"
			elif echo "$jq_error" | grep -qi "Expected.*double quotes"; then
				echo "Invalid JSON: Property names must be in double quotes"
			else
				echo "Invalid JSON: $jq_error"
			fi
			return 1
		fi
	else
		# Fall back to Python
		# SECURITY: Pass file path as argument to prevent command injection
		if ! python3 -c "
import json
import sys

try:
    with open(sys.argv[1], 'r') as f:
        json.load(f)
    sys.exit(0)
except json.JSONDecodeError as e:
    # Parse Python error for common issues
    error_msg = str(e).lower()
    if 'expecting property name' in error_msg:
        if 'line' in error_msg:
            print(f'Invalid JSON: Trailing comma detected (around {e.msg})')
        else:
            print('Invalid JSON: Trailing comma detected')
    elif 'expecting value' in error_msg:
        print('Invalid JSON: Empty file or missing value')
    elif 'invalid' in error_msg:
        print(f'Invalid JSON: {e.msg}')
    else:
        print(f'Invalid JSON: {e}')
    sys.exit(1)
except Exception as e:
    print(f'Error reading file: {e}')
    sys.exit(1)
" "$file" 2>&1; then
			return 1
		fi
	fi

	# JSON is valid
	return 0
}

# Format JSON error message with helpful suggestions
format_json_error() {
	local file="$1"
	local validation_result

	if ! validation_result=$(validate_json "$file" 2>&1); then
		echo ""
		echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
		echo "‚ö†Ô∏è  Invalid JSON Configuration"
		echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
		echo "File: $file"
		echo "Error: $validation_result"
		echo ""

		# Provide specific fix suggestions with examples
		if echo "$validation_result" | grep -qi "trailing comma"; then
			echo "üîß How to fix:"
			echo "   Remove the comma after the last property"
			echo ""
			echo "   ‚ùå Wrong:    \"name\": \"My Project\","
			echo "                }"
			echo "   ‚úÖ Correct:  \"name\": \"My Project\""
			echo "                }"
		elif echo "$validation_result" | grep -qi "quotes"; then
			echo "üîß How to fix:"
			echo "   Ensure all property names use double quotes"
			echo ""
			echo "   ‚ùå Wrong:    projectName: \"My Project\""
			echo "   ‚úÖ Correct:  \"projectName\": \"My Project\""
		elif echo "$validation_result" | grep -qi "empty"; then
			echo "üîß How to fix:"
			echo "   Add valid JSON content, for example:"
			echo ""
			echo "   {"
			echo "     \"commandCentral.project.name\": \"My Project\","
			echo "     \"commandCentral.project.icon\": \"üöÄ\""
			echo "   }"
		else
			echo "üîß How to fix:"
			echo "   1. Check for missing brackets, quotes, or commas"
			echo "   2. Validate at: https://jsonlint.com/"
			echo "   3. Or use: cat $file | jq ."
		fi
		echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
		echo ""

		return 1
	fi

	return 0
}

# Load VSCode configuration if available
load_vscode_config() {
	local dir="$1"
	local vscode_settings="$dir/.vscode/settings.json"

	# Initialize variables
	local project_icon=""
	local project_name=""
	local ghostty_theme=""
	local shell_env=""
	# Background image settings with sensible defaults
	local bg_enabled="true"
	local bg_opacity="0.07"
	local bg_position="top-right"
	local bg_fit="none"
	local bg_margin="60"
	local bg_max_width="300"

	if [[ -f "$vscode_settings" ]]; then
		# First validate the JSON
		local validation_error
		if ! validation_error=$(validate_json "$vscode_settings" 2>&1); then
			# Use the improved error formatter
			format_json_error "$vscode_settings" >&2
			echo "üìù Creating launcher without custom settings..." >&2
			echo "" >&2

			# Log the error for debugging
			log "JSON validation failed for $vscode_settings: $validation_error"
		else
			# JSON is valid - proceed with parsing
			if command -v jq >/dev/null 2>&1; then
				# Use jq for all JSON fields (using new flat dot-notation keys)
				project_icon=$(jq -r '."commandCentral.project.icon" // ""' "$vscode_settings" 2>/dev/null || true)
				project_name=$(jq -r '."commandCentral.project.name" // ""' "$vscode_settings" 2>/dev/null || true)
				ghostty_theme=$(jq -r '."commandCentral.terminal.theme" // ""' "$vscode_settings" 2>/dev/null || true)
				# Background settings with defaults
				bg_enabled=$(jq -r '."commandCentral.terminal.backgroundImage.enabled" // "true"' "$vscode_settings" 2>/dev/null || echo "true")
				bg_opacity=$(jq -r '."commandCentral.terminal.backgroundImage.opacity" // "0.07"' "$vscode_settings" 2>/dev/null || echo "0.07")
				bg_position=$(jq -r '."commandCentral.terminal.backgroundImage.position" // "top-right"' "$vscode_settings" 2>/dev/null || echo "top-right")
				bg_fit=$(jq -r '."commandCentral.terminal.backgroundImage.fit" // "none"' "$vscode_settings" 2>/dev/null || echo "none")
				bg_margin=$(jq -r '."commandCentral.terminal.backgroundImage.margin" // "60"' "$vscode_settings" 2>/dev/null || echo "60")
				bg_max_width=$(jq -r '."commandCentral.terminal.backgroundImage.maxWidth" // "300"' "$vscode_settings" 2>/dev/null || echo "300")
			else
				# Fall back to Python (always available on macOS)
				# SECURITY: Pass file path as argument to prevent command injection
				local python_output
				python_output=$(python3 -c "
import json
import sys

try:
    with open(sys.argv[1], 'r') as f:
        config = json.load(f)
        # Extract all fields in one pass (using new flat dot-notation keys)
        icon = config.get('commandCentral.project.icon', '')
        name = config.get('commandCentral.project.name', '')
        theme = config.get('commandCentral.terminal.theme', '')
        # Background settings with defaults
        bg_enabled = config.get('commandCentral.terminal.backgroundImage.enabled', True)
        bg_opacity = config.get('commandCentral.terminal.backgroundImage.opacity', 0.07)
        bg_position = config.get('commandCentral.terminal.backgroundImage.position', 'top-right')
        bg_fit = config.get('commandCentral.terminal.backgroundImage.fit', 'none')
        bg_margin = config.get('commandCentral.terminal.backgroundImage.margin', 60)
        bg_max_width = config.get('commandCentral.terminal.backgroundImage.maxWidth', 300)
        # Convert boolean to string for consistent handling
        bg_enabled_str = 'true' if bg_enabled else 'false'
        print(f'{icon}|{name}|{theme}|{bg_enabled_str}|{bg_opacity}|{bg_position}|{bg_fit}|{bg_margin}|{bg_max_width}')
except:
    print('||||||||')
" "$vscode_settings" 2>/dev/null || echo "||||||||")

				# Parse the pipe-separated output
				IFS='|' read -r project_icon project_name ghostty_theme bg_enabled bg_opacity bg_position bg_fit bg_margin bg_max_width <<<"$python_output"
				# Set defaults if empty
				bg_enabled="${bg_enabled:-true}"
				bg_opacity="${bg_opacity:-0.07}"
				bg_position="${bg_position:-top-right}"
				bg_fit="${bg_fit:-none}"
				bg_margin="${bg_margin:-60}"
				bg_max_width="${bg_max_width:-300}"
			fi

			# Extract shellEnv using existing robust function
			shell_env=$(extract_shell_env "$vscode_settings")

			log "Loaded VSCode config: name='$project_name', icon='$project_icon', theme='$ghostty_theme', bg='${bg_enabled}/${bg_opacity}/${bg_position}', env=[$(echo "$shell_env" | wc -l) vars]"
		fi
	fi

	# Return pipe-separated values with base64 encoding for env vars to handle newlines
	# Added background settings to the return value
	if [[ -n "$shell_env" ]]; then
		local encoded_env
		encoded_env=$(echo "$shell_env" | base64)
		echo "${project_icon}|${project_name}|${ghostty_theme}|BASE64:${encoded_env}|${bg_enabled}|${bg_opacity}|${bg_position}|${bg_fit}|${bg_margin}|${bg_max_width}"
	else
		echo "${project_icon}|${project_name}|${ghostty_theme}||${bg_enabled}|${bg_opacity}|${bg_position}|${bg_fit}|${bg_margin}|${bg_max_width}"
	fi
}

# Check if input is an emoji
is_emoji() {
	local input="$1"
	# Check for common emoji Unicode ranges using UTF-8
	# Ranges include: arrows, symbols, pictographs, emoticons, dingbats, variation selectors, etc.
	# Note: \x{FE0F} is variation selector-16 (emoji presentation)
	# Note: \x{FE0E} is variation selector-15 (text presentation)
	echo "$input" | perl -CS -ne 'print if /[\x{2190}-\x{21FF}]|[\x{2300}-\x{27BF}]|[\x{2B00}-\x{2BFF}]|[\x{1F300}-\x{1F9FF}]|[\x{1F680}-\x{1F6FF}]|[\x{1F900}-\x{1F9FF}]/' | perl -CS -pe 's/[\x{FE0E}\x{FE0F}]//g'
}

# Get project info from directory
get_project_info() {
	local dir="${1:-$(pwd)}"
	dir="$(cd "$dir" && pwd)" # Absolute path

	# Load VSCode config (includes env vars and background settings in pipe-delimited format)
	local vscode_config
	vscode_config="$(load_vscode_config "$dir")"

	# Efficiently parse all fields without subshells
	# Since load_vscode_config returns icon|name|theme|env_vars|bg_enabled|bg_opacity|bg_position|bg_fit|bg_margin|bg_max_width
	# We need to handle the case where env_vars might contain newlines

	# Get first line without subshell
	local first_line="${vscode_config%%$'\n'*}"

	# Parse all fields at once including background settings
	local vscode_icon vscode_name vscode_theme vscode_env_first bg_enabled bg_opacity bg_position bg_fit bg_margin bg_max_width
	IFS='|' read -r vscode_icon vscode_name vscode_theme vscode_env_first bg_enabled bg_opacity bg_position bg_fit bg_margin bg_max_width <<<"$first_line"

	# Keep base64 encoding - don't decode here to preserve newlines
	local vscode_env="$vscode_env_first"

	# Use VSCode name or fallback to directory name
	local name="${vscode_name:-$(basename "$dir")}"

	# Return the original name without sanitizing (let caller handle it), including env vars (still base64) and background settings
	echo "$name|$dir|$vscode_icon|$vscode_theme|$vscode_env|$bg_enabled|$bg_opacity|$bg_position|$bg_fit|$bg_margin|$bg_max_width"
}

# Generate icon (emoji or default)
generate_icon() {
	local name="$1"
	local icon_path="$2"
	local emoji="${3:-}"

	if [[ -n "$emoji" ]] && [[ -n "$(is_emoji "$emoji")" ]] && command -v sips >/dev/null 2>&1; then
		# Try to generate emoji icon
		if generate_emoji_icon "$emoji" "$icon_path"; then
			log "Generated emoji icon for $name: $emoji"
			return 0
		fi
	fi

	# Fallback: Use different system icons based on name hash
	local icons=(
		"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericFolderIcon.icns"
		"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/DeveloperFolderIcon.icns"
		"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ToolbarCustomizeIcon.icns"
		"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/SidebarMacIcon.icns"
	)

	local hash
	hash=$(echo -n "$name" | cksum | cut -d' ' -f1)
	local idx=$((hash % ${#icons[@]}))
	local system_icon="${icons[$idx]}"

	if [[ -f "$system_icon" ]]; then
		cp "$system_icon" "$icon_path" 2>/dev/null || cp "${TERMINAL_APP}/Contents/Resources/Ghostty.icns" "$icon_path" 2>/dev/null || touch "$icon_path"
	else
		cp "${TERMINAL_APP}/Contents/Resources/Ghostty.icns" "$icon_path" 2>/dev/null || touch "$icon_path"
	fi
}

# Generate emoji icon using sips
# Creates a proper .icns file from an emoji character using macOS's built-in JavaScript engine
# Parameters:
#   $1 - emoji: The emoji character to convert
#   $2 - output_path: Where to save the resulting .icns file
# Returns: 0 on success, 1 on failure
# Process:
#   1. Creates multiple resolution PNG files (16x16 to 512x512)
#   2. Uses JavaScript via sips to render emoji with proper scaling
#   3. Combines PNGs into .icns format using iconutil
generate_emoji_icon() {
	local emoji="$1"
	local output_path="$2"
	local temp_dir
	temp_dir=$(mktemp -d)

	# Create iconset directory
	local iconset_dir="$temp_dir/icon.iconset"
	mkdir -p "$iconset_dir"

	# Generate all required icon sizes at native resolution
	local -a icon_sizes=(
		"512:512:icon_512x512.png"
		"256:256:icon_256x256.png"
		"128:128:icon_128x128.png"
		"32:32:icon_32x32.png"
		"16:16:icon_16x16.png"
	)

	for size_spec in "${icon_sizes[@]}"; do
		IFS=':' read -r _ pixels filename <<<"$size_spec"

		# Escape emoji for safe JavaScript embedding
		# SECURITY: Escape backslashes FIRST, then quotes to prevent injection
		local escaped_emoji
		escaped_emoji=$(printf '%s' "$emoji" | sed 's/\\/\\\\/g; s/'"'"'/\\'"'"'/g; s/"/\\"/g')

		# Render each size at its native resolution
		cat >"$temp_dir/render_${pixels}.js" <<EOF
// Create canvas at exact target size
const canvas = new Canvas(${pixels}, ${pixels})
const ctx = canvas.getContext('2d')

// Clear with transparency
ctx.fillStyle = 'rgba(0, 0, 0, 0)'
ctx.fillRect(0, 0, ${pixels}, ${pixels})

// Calculate scale for THIS specific size
const iconSize = ${pixels}
const targetFill = iconSize * 0.8  // 80% fill
const baseGlyphSize = 16  // Approximate emoji size at scale 1
const scale = targetFill / baseGlyphSize

// Render emoji at native resolution for this size
ctx.save()
ctx.fillStyle = 'black'
ctx.translate(iconSize / 2, iconSize / 2)  // Center
ctx.scale(scale, scale)
ctx.textAlign = 'center'
ctx.textBaseline = 'middle'

// EMOJI VERTICAL CENTERING CORRECTION
//
// Canvas textBaseline='middle' aligns to the typographic em-box center, NOT the visual
// glyph center. This is fundamental to all text rendering systems (Canvas, Pillow, CoreText).
//
// Apple Color Emoji uses 160x160px PNG bitmaps in 'sbix' table. Font metrics (ascent/descent)
// don't match visual content, causing emoji to render too high with asymmetric margins.
//
// Vertical compensation of -3.0 (negative shifts DOWN) corrects this by aligning visual center
// with canvas center. This value was derived from pixel-perfect measurements across multiple
// emoji and canvas sizes, achieving 0px asymmetry for 90% of emoji.
//
// This is NOT a hack - it's the correct solution to a universal typography limitation.
// Alternative technologies (ImageMagick, Pillow, Node canvas, Swift CoreText) all suffer
// from the same issue or worse. sips + Canvas is the optimal native macOS approach.
//
// Technical details and alternatives evaluated in EMOJI_CENTERING_INVESTIGATION.md
const verticalCompensation = -3.0

ctx.fillText('${escaped_emoji}', 0, verticalCompensation)
ctx.restore()

// Export
const output = new Output(canvas, sips.outputPath)
output.addToQueue()
EOF

		# Render this specific size
		if ! sips -j "$temp_dir/render_${pixels}.js" -o "$iconset_dir/$filename" 2>&1; then
			log "Warning: Could not generate emoji icon for $emoji, using fallback icon"
			rm -rf "$temp_dir"
			return 1
		fi
	done

	# Create @2x versions
	cp "$iconset_dir/icon_256x256.png" "$iconset_dir/icon_128x128@2x.png" 2>/dev/null
	cp "$iconset_dir/icon_512x512.png" "$iconset_dir/icon_256x256@2x.png" 2>/dev/null

	# Convert iconset to icns
	if ! iconutil -c icns "$iconset_dir" -o "$output_path" 2>/dev/null; then
		rm -rf "$temp_dir"
		return 1
	fi

	# Cleanup
	rm -rf "$temp_dir"
	return 0
}

# Generate emoji background PNG for terminal watermark
# Creates a position-independent PNG from emoji (no margin padding)
# Parameters:
#   $1 - emoji: The emoji character to convert
#   $2 - output_path: Where to save the resulting PNG file
#   $3 - position: Passed to Ghostty config (not used for PNG sizing)
#   $4 - margin: Passed to Ghostty config (not baked into PNG)
#   $5 - max_width: Maximum emoji width in pixels (default: 300)
# Returns: 0 on success, 1 on failure
#
# New Architecture:
#   - PNG is position-independent (always emoji_size x emoji_size)
#   - No transparent padding/margin in PNG
#   - Ghostty's background-image-margin handles offset
#   - Cleaner separation of concerns
#
# Examples:
#   maxWidth=300, square emoji (üüß) ‚Üí 300x300 canvas for ALL positions
#   maxWidth=300, tall emoji (ü•Ç) ‚Üí 300x??? canvas (aspect ratio preserved)
#   maxWidth=300, wide emoji (üêñ) ‚Üí ???x300 canvas (aspect ratio preserved)
generate_emoji_background() {
	local emoji="$1"
	local output_path="$2"
	local position="${3:-top-right}" # Default to top-right for backward compatibility
	local margin="${4:-60}"          # Default 60px margin
	local max_width="${5:-300}"      # Default 300px max width
	local temp_dir
	temp_dir=$(mktemp -d)

	# Canvas sizing: position-independent, no margin padding
	# PNG contains just the emoji at maxWidth, Ghostty handles margin via config
	local emoji_size="$max_width"

	# Canvas size = emoji size (no transparent padding)
	local canvas_width=$emoji_size
	local canvas_height=$emoji_size

	# Center emoji in canvas
	local pos_x=$((canvas_width / 2))
	local pos_y=$((canvas_height / 2))
	local text_baseline="middle"

	# Escape emoji for safe JavaScript embedding
	# SECURITY: Escape backslashes FIRST, then quotes to prevent injection
	local escaped_emoji
	escaped_emoji=$(printf '%s' "$emoji" | sed 's/\\/\\\\/g; s/'"'"'/\\'"'"'/g; s/"/\\"/g')

	# EMOJI VERTICAL CENTERING CORRECTION
	#
	# Canvas textBaseline='middle' aligns to typographic em-box center, NOT visual center.
	# This is fundamental to all text rendering - not specific to sips or emoji.
	#
	# Value of -3.0 (negative shifts DOWN) provides optimal centering for 90% of emoji,
	# derived from pixel-perfect measurements. Consistent with icon generation.
	#
	# See EMOJI_CENTERING_INVESTIGATION.md for full technical analysis.
	local vert_comp="-3.0"

	# Create JavaScript for sips rendering with simplified positioning
	cat >"$temp_dir/render_bg.js" <<EOF
// Position-independent PNG: no margin padding, Ghostty handles offset via config
// Canvas: ${canvas_width}x${canvas_height}, Emoji fills canvas completely
const canvas = new Canvas(${canvas_width}, ${canvas_height})
const ctx = canvas.getContext('2d')

// Clear with transparency
ctx.fillStyle = 'rgba(0, 0, 0, 0)'
ctx.fillRect(0, 0, ${canvas_width}, ${canvas_height})

// Emoji fills the canvas at specified size
const emojiSize = ${emoji_size}
const posX = ${pos_x}
const posY = ${pos_y}

// Calculate scale to fit emoji in canvas WITHOUT cropping
// 75% fill maximizes canvas usage while preventing edge cut-off
// Vertical compensation (-3.0) handles centering separately
const targetFill = emojiSize * 0.75  // 75% fill factor
const baseGlyphSize = 16  // Match icon generation for consistency
const scale = targetFill / baseGlyphSize

// Render emoji centered in canvas
ctx.save()
ctx.fillStyle = 'black'
ctx.translate(posX, posY)
ctx.scale(scale, scale)
ctx.textAlign = 'center'
ctx.textBaseline = '${text_baseline}'

// EMOJI VERTICAL CENTERING CORRECTION
// Corrects for textBaseline='middle' using typographic em-box instead of visual center.
// Value of -3.0 provides optimal centering (same as icon generation).
// See EMOJI_CENTERING_INVESTIGATION.md for technical details.
const verticalCompensation = ${vert_comp}

// Don't set ctx.font - let sips use default emoji rendering (like generate_icon does)
ctx.fillText('${escaped_emoji}', 0, verticalCompensation)
ctx.restore()

// Export PNG
const output = new Output(canvas, sips.outputPath)
output.addToQueue()
EOF

	# Render the PNG using sips JavaScript engine
	if ! sips -j "$temp_dir/render_bg.js" -o "$output_path" 2>&1; then
		log "Warning: Could not generate background PNG for $emoji at position $position"
		rm -rf "$temp_dir"
		return 1
	fi

	# Cleanup temporary files
	rm -rf "$temp_dir"
	return 0
}

# Set icon for Projects folder using NSWorkspace
set_projects_folder_icon() {
	local emoji="${1:-üìÅ}"

	# Generate folder icon using existing emoji function
	local temp_icon="/tmp/projects_folder_$$.icns"

	if ! generate_emoji_icon "$emoji" "$temp_icon"; then
		log "Warning: Could not generate folder icon"
		return 1
	fi

	# SECURITY: Escape paths for safe AppleScript interpolation
	# Escape backslashes first, then double quotes
	local escaped_temp_icon escaped_projects_folder
	escaped_temp_icon=$(printf '%s' "$temp_icon" | sed 's/\\/\\\\/g; s/"/\\"/g')
	escaped_projects_folder=$(printf '%s' "$PROJECTS_FOLDER" | sed 's/\\/\\\\/g; s/"/\\"/g')

	# Apply icon using NSWorkspace (modern macOS method)
	local result
	result=$(
		osascript <<EOF 2>&1
use framework "AppKit"
use framework "Foundation"

on run
    try
        set iconNSURL to current application's |NSURL|'s fileURLWithPath:"${escaped_temp_icon}"
        set iconImage to current application's NSImage's alloc()'s initWithContentsOfURL:iconNSURL

        if iconImage is missing value then
            return "ERROR: Could not load icon"
        end if

        set success to current application's NSWorkspace's sharedWorkspace()'s setIcon:iconImage forFile:"${escaped_projects_folder}" options:0

        if success then
            return "SUCCESS"
        else
            return "ERROR: setIcon returned false"
        end if
    on error errMsg
        return "ERROR: " & errMsg
    end try
end run
EOF
	)

	if [[ "$result" == "SUCCESS" ]]; then
		# Set custom icon flag
		SetFile -a C "$PROJECTS_FOLDER" 2>/dev/null || true
		log "Set Projects folder icon"
	else
		log "Could not set folder icon: $result"
	fi

	# Cleanup
	rm -f "$temp_icon"
}

# Ensure projects folder exists
ensure_folder_exists() {
	if [[ ! -d "$PROJECTS_FOLDER" ]]; then
		if ! mkdir -p "$PROJECTS_FOLDER" 2>/dev/null; then
			echo "Error: Cannot create $PROJECTS_FOLDER"
			echo ""
			echo "To fix this, run:"
			echo "  sudo mkdir -p '$PROJECTS_FOLDER' && sudo chown $USER '$PROJECTS_FOLDER'"
			echo ""
			die "Permission denied for $PROJECTS_FOLDER"
		fi

		log "Created projects folder at $PROJECTS_FOLDER"
		echo "Created Projects folder at: $PROJECTS_FOLDER"
		echo ""
		echo "To add to dock: Drag the folder to your dock"
		echo "It will appear as a stack with all your project terminals."
	fi

	# Always ensure folder has icon (check if not already set)
	local attrs
	attrs=$(GetFileInfo -a "$PROJECTS_FOLDER" 2>/dev/null || echo "")
	if [[ ! "$attrs" =~ C ]]; then
		set_projects_folder_icon "$PROJECTS_FOLDER_EMOJI"
	fi
}

# Smart open - simplified to use folder
smart_open() {
	local target_dir="${1:-$(pwd)}"

	# SECURITY FIX: Validate against path traversal attacks
	if [[ "$target_dir" =~ \.\. ]]; then
		die "Security error: Directory path contains '..' traversal sequences"
	fi

	# Resolve to absolute path safely
	target_dir="$(cd "$target_dir" 2>/dev/null && pwd)" || die "Directory not found: $target_dir"

	# Validate directory is not empty or system critical
	if [[ "$target_dir" == "/" ]] || [[ "$target_dir" == "/System" ]] || [[ "$target_dir" == "/Library" ]]; then
		die "Cannot create launcher for system directory: $target_dir"
	fi

	# Additional safety check - warn if outside home directory
	if [[ "$target_dir" != "$HOME"* ]] && [[ "$target_dir" != "/Users/$USER"* ]]; then
		log "Warning: Directory outside home directory: $target_dir"
		# Skip interactive prompt in test mode
		if [[ "${GHOSTTY_TEST_MODE:-}" == "1" ]]; then
			log "Test mode: auto-confirming outside-home directory"
		else
			echo "‚ö†Ô∏è  Warning: Creating launcher for directory outside home: $target_dir" >&2
			read -p "Continue? (y/N) " -n 1 -r
			echo
			if [[ ! $REPLY =~ ^[Yy]$ ]]; then
				echo "Cancelled."
				exit 0
			fi
		fi
	fi

	# Ensure folder exists
	ensure_folder_exists

	# Get project info (includes VSCode settings and env vars)
	local project_info
	project_info="$(get_project_info "$target_dir")"

	# Parse all fields in one pass using IFS - no subshells needed
	# Get first line efficiently without spawning subshell
	local first_line="${project_info%%$'\n'*}"

	# Parse pipe-delimited fields in single operation including background settings
	local project_name project_dir emoji theme env_first bg_enabled bg_opacity bg_position bg_fit bg_margin bg_max_width
	IFS='|' read -r project_name project_dir emoji theme env_first bg_enabled bg_opacity bg_position bg_fit bg_margin bg_max_width <<<"$first_line"

	# Handle base64-encoded environment variables
	local env_vars="$env_first"
	if [[ "$env_first" =~ ^BASE64: ]]; then
		# Decode base64-encoded env vars with error handling
		local encoded="${env_first#BASE64:}"
		if [[ -n "$encoded" ]]; then
			env_vars=$(echo "$encoded" | base64 -d 2>/dev/null) || {
				log "Warning: Failed to decode environment variables from .vscode/settings.json shellEnv"
				echo "Warning: Could not decode shellEnv from .vscode/settings.json - environment variables will not be set" >&2
				env_vars=""
			}
		else
			env_vars=""
		fi
	fi

	# Validate project name for special characters
	if ! validate_project_name "$project_name"; then
		die "Project name contains invalid characters: $project_name
Only letters, numbers, dots, dashes, underscores, and spaces are allowed."
	fi

	# Handle edge cases for dot patterns
	if [[ "$project_name" == "." ]]; then
		die "Project name cannot be a single dot"
	fi

	if [[ "$project_name" =~ ^\.+$ ]]; then
		die "Project name cannot consist only of dots"
	fi

	# Check launcher name length (macOS has practical limits)
	if [[ ${#project_name} -gt 255 ]]; then
		die "Project name too long (${#project_name} characters, max 255)"
	fi

	# Keep original name for display
	local display_name="$project_name"
	local safe_name
	safe_name="$(sanitize_name "$project_name")"

	# Handle dot-prefixed names for launcher filename
	# Convert .config to "Dot Config" for filesystem visibility
	local launcher_name="$display_name"
	if [[ "$display_name" =~ ^\. ]]; then
		# Replace leading dot with 'Dot ' and capitalize for visibility in Dock
		# Example: .config -> Dot Config, .ssh -> Dot Ssh
		local name_part="${display_name:1}"
		# Capitalize first letter using printf (more portable than bash 4 features)
		launcher_name="Dot $(printf "%s" "$name_part" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')"

		# Validate the converted launcher name is still filesystem-safe
		if ! validate_project_name "$launcher_name"; then
			die "Converted launcher name contains invalid characters: $launcher_name"
		fi

		log "Converting dot-prefixed name: $display_name -> $launcher_name"
	fi

	# Clean up any old launchers for this project with different names
	# This handles the case where the project name changed in VSCode settings
	# Pass both the launcher name and display name for comprehensive cleanup
	cleanup_old_launchers_for_project "$project_dir" "$launcher_name" "$display_name"

	# Launcher goes directly in folder with visible name
	local launcher_path="${PROJECTS_FOLDER}/${launcher_name}.app"

	# Check if launcher exists and is up to date
	if [[ -d "$launcher_path" ]]; then
		# Check if metadata matches
		local metadata_file="${launcher_path}/Contents/.metadata"
		if [[ -f "$metadata_file" ]]; then
			local stored_dir
			stored_dir=$(read_app_metadata "$launcher_path" "dir")

			# Validate that the stored directory still exists
			if [[ -n "$stored_dir" ]] && [[ ! -d "$stored_dir" ]]; then
				log "Project directory no longer exists: $stored_dir"
				echo "Warning: Project directory no longer exists: $stored_dir" >&2
				read -p "Remove orphaned launcher? (y/n) " -n 1 -r
				echo
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					rm -rf "$launcher_path"
					echo "Removed orphaned launcher: $project_name"
				fi
				exit 1
			fi

			local stored_hash
			stored_hash=$(read_app_metadata "$launcher_path" "config_hash")
			# Include env_vars and launcher_name in the hash to detect changes
			local current_hash
			current_hash=$(echo -n "${project_dir}|${display_name}|${launcher_name}|${emoji}|${theme}|${env_vars}" | shasum -a 256 | cut -d' ' -f1)

			if [[ "$stored_dir" == "$project_dir" ]] && [[ "$stored_hash" == "$current_hash" ]]; then
				# Launcher exists and config hasn't changed - just open it
				log "Opening existing launcher for $display_name"
				if [[ "${GHOSTTY_TEST_MODE:-}" != "1" ]]; then
					open "$launcher_path"
				fi
				return 0
			elif [[ "$stored_dir" == "$project_dir" ]]; then
				# Config changed - need to recreate
				log "Configuration changed, updating launcher for $display_name"
				rm -rf "$launcher_path"
			fi
		fi
	fi

	# Need to create/update launcher (now passing env_vars, launcher_name, and background settings)
	create_launcher "$safe_name" "$display_name" "$project_dir" "$emoji" "$theme" "$launcher_path" "$env_vars" "$launcher_name" \
		"$bg_enabled" "$bg_opacity" "$bg_position" "$bg_fit" "$bg_margin" "$bg_max_width"

	# Open the newly created launcher
	if [[ "${GHOSTTY_TEST_MODE:-}" != "1" ]]; then
		open "$launcher_path"
	fi
}

# Create a launcher app at specific path
# Builds a complete macOS app bundle structure for launching Ghostty with specific settings
# Parameters:
#   $1 - safe_name: Sanitized name for filesystem use
#   $2 - display_name: Human-readable name for display
#   $3 - dir: Working directory for the terminal
#   $4 - emoji: Optional emoji for icon and window title
#   $5 - theme: Optional Ghostty theme name (if not provided, Ghostty uses its own default)
#   $6 - app_path: Full path where app bundle should be created
#   $7 - env_vars: Optional environment variables (newline-separated KEY=VALUE pairs)
#   $8 - launcher_name: Optional launcher filename (for dot-prefixed handling)
#   $9 - bg_enabled: Background image enabled (default: true)
#   $10 - bg_opacity: Background image opacity (default: 0.07)
#   $11 - bg_position: Background image position (default: top-right)
#   $12 - bg_fit: Background image fit (default: none)
#   $13 - bg_margin: Background image margin in pixels (default: 60)
#   $14 - bg_max_width: Background image max width in pixels (default: 300)
# Creates:
#   - Info.plist with app metadata
#   - Launcher script in MacOS/run
#   - Icon file in Resources/
#   - Metadata file for tracking changes
# Returns: 0 on success, exits on failure
create_launcher() {
	local safe_name="$1"
	local display_name="$2"
	local dir="$3"
	local emoji="${4:-}"
	local theme="${5:-}" # Theme is optional
	local app_path="$6"
	local env_vars="${7:-}"
	local launcher_name="${8:-$display_name}"
	# Background image settings
	local bg_enabled="${9:-true}"
	local bg_opacity="${10:-0.07}"
	local bg_position="${11:-top-right}"
	local bg_fit="${12:-none}"
	local bg_margin="${13:-60}"
	local bg_max_width="${14:-300}"

	# Validate numeric parameters to prevent invalid config values
	if ! [[ "$bg_margin" =~ ^[0-9]+$ ]]; then
		log "Warning: Invalid bg_margin '$bg_margin', using default 60"
		bg_margin="60"
	fi
	if ! [[ "$bg_max_width" =~ ^[0-9]+$ ]]; then
		log "Warning: Invalid bg_max_width '$bg_max_width', using default 300"
		bg_max_width="300"
	fi

	# Use mkdir for atomic locking with PID for better cleanup
	local lock_dir="/tmp/ghostty-launcher.lock"
	local lock_pid_file="$lock_dir/pid"
	local max_wait=30 # Increased timeout for slower systems
	local waited=0

	# Cleanup function for lock
	cleanup_lock() {
		# Only clean up if we own the lock
		if [[ -f "$lock_pid_file" ]] && [[ "$(cat "$lock_pid_file" 2>/dev/null)" == "$$" ]]; then
			rm -rf "$lock_dir" 2>/dev/null || true
		fi
	}

	# Try to acquire lock
	while ! mkdir "$lock_dir" 2>/dev/null; do
		# Check if lock is stale (process no longer exists)
		if [[ -f "$lock_pid_file" ]]; then
			local lock_pid
			lock_pid=$(cat "$lock_pid_file" 2>/dev/null || echo "0")
			if ! kill -0 "$lock_pid" 2>/dev/null; then
				log "Removing stale lock from PID $lock_pid"
				# SECURITY FIX: Atomic check-and-remove to prevent TOCTOU race condition
				# Remove stale lock and immediately try to acquire in one operation
				if rm -rf "$lock_dir" 2>/dev/null && mkdir "$lock_dir" 2>/dev/null; then
					break # We got the lock atomically
				fi
				# Someone else beat us to it, retry from the top
				continue
			fi
		else
			# Edge case: Lock directory exists but PID file is missing (orphaned lock)
			# This can happen if process was killed between mkdir and writing PID
			log "Removing orphaned lock directory (no PID file)"
			if rm -rf "$lock_dir" 2>/dev/null && mkdir "$lock_dir" 2>/dev/null; then
				break # We got the lock atomically
			fi
			continue
		fi

		if [[ $waited -ge $max_wait ]]; then
			die "Failed to acquire lock (timeout after ${max_wait}s)
Another ghostty process may be running. Try again in a moment."
		fi
		sleep 0.1
		((waited++))
	done

	# Store our PID in the lock
	echo "$$" >"$lock_pid_file"

	# Ensure lock is released on exit and all signals
	trap cleanup_lock EXIT INT TERM HUP

	local contents="${app_path}/Contents"

	log "Creating launcher at: $app_path for $display_name in $dir"

	# Force unregister the old app bundle if it exists
	if [[ -d "$app_path" ]]; then
		/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -u "$app_path" 2>/dev/null || true
	fi

	# Create app structure
	mkdir -p "${contents}/MacOS" "${contents}/Resources"

	# Generate bundle ID using display name to preserve dot prefix
	local bundle_id
	bundle_id=$(generate_bundle_id "$display_name")

	# Generate URL scheme for notification routing
	local url_scheme
	url_scheme=$(generate_url_scheme "$safe_name")

	# Create Info.plist
	cat >"${contents}/Info.plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>run</string>
    <key>CFBundleName</key>
    <string>${display_name}</string>
    <key>CFBundleDisplayName</key>
    <string>${display_name}</string>
    <key>CFBundleIconFile</key>
    <string>icon.icns</string>
    <key>CFBundleIdentifier</key>
    <string>${bundle_id}</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleTypeRole</key>
            <string>Viewer</string>
            <key>CFBundleURLName</key>
            <string>Command Central Project Notification Router</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>${url_scheme}</string>
            </array>
        </dict>
    </array>
    <key>LSUIElement</key>
    <false/>
    <key>LSHasLocalizedDisplayName</key>
    <true/>
    <key>LSMultipleInstancesProhibited</key>
    <false/>
    <key>LSArchitecturePriority</key>
    <array>
        <string>arm64e</string>
        <string>arm64</string>
        <string>x86_64</string>
    </array>
    <key>LSRequiresNativeExecution</key>
    <true/>
</dict>
</plist>
EOF

	# Create localization structure for proper dock name display
	local en_lproj="${contents}/Resources/en.lproj"
	mkdir -p "$en_lproj"

	# Create InfoPlist.strings with localized display name
	cat >"${en_lproj}/InfoPlist.strings" <<EOF
/* Localized display name for dock */
"CFBundleDisplayName" = "${display_name}";
"CFBundleName" = "${display_name}";
EOF

	# Create icon FIRST (before script generation)
	generate_icon "$display_name" "${contents}/Resources/icon.icns" "$emoji"

	# Generate background PNG if background is enabled and emoji exists
	# This must happen BEFORE launcher script creation so file check works
	if [[ "$bg_enabled" == "true" ]] && [[ -n "$emoji" ]] && [[ -n "$(is_emoji "$emoji")" ]]; then
		generate_emoji_background "$emoji" "${contents}/Resources/background.png" "$bg_position" "$bg_margin" "$bg_max_width"
		log "Generated background watermark for $display_name: $emoji (position: $bg_position, margin: ${bg_margin}px, max_width: ${bg_max_width}px)"
	fi

	# Create launcher script named 'run' (not the app name!)
	local script_path="${contents}/MacOS/run"

	cat >"$script_path" <<'SCRIPT_HEADER'
#!/bin/bash
# Direct execution of Ghostty
# This ensures Ghostty's own permissions are used for notifications
SCRIPT_HEADER

	# Escape variables to prevent command injection
	local safe_dir
	safe_dir=$(printf '%q' "$dir")
	# NOTE: --title removed to allow dynamic titles from Claude Code via OSC sequences

	# Add working directory variable and validation
	cat >>"$script_path" <<EOF

# Set working directory
WORKING_DIR=$safe_dir

# Verify working directory exists
if [[ ! -d "\$WORKING_DIR" ]]; then
    echo "Error: Project directory not found: \$WORKING_DIR" >&2
    echo "The project directory may have been moved or deleted." >&2
    echo "" >&2
    echo "To fix this, either:" >&2
    echo "  1. Restore the directory: \$WORKING_DIR" >&2
    echo "  2. Remove this launcher using: ghostty remove '$display_name'" >&2
    exit 1
fi

EOF

	# Build environment variable parameters for --env flags
	local env_params=""
	if [[ -n "$env_vars" ]]; then
		while IFS= read -r env_line; do
			if [[ -n "$env_line" ]]; then
				# Parse KEY=VALUE format
				if [[ "$env_line" =~ ^([^=]+)=(.*)$ ]]; then
					local key="${BASH_REMATCH[1]}"
					local value="${BASH_REMATCH[2]}"
					# SECURITY FIX: Escape special characters to prevent command injection
					# We need to escape: \ " $ ` to prevent any form of command execution
					local escaped_value="${value//\\/\\\\}"   # Escape backslashes first
					escaped_value="${escaped_value//\"/\\\"}" # Escape quotes
					escaped_value="${escaped_value//\$/\\\$}" # Escape dollar signs
					escaped_value="${escaped_value//\`/\\\`}" # Escape backticks
					# Always quote for consistency (--env="KEY=VALUE" format per Developer Guide)
					# Note: Using literal newline to work correctly with heredoc
					env_params="${env_params}    --env=\"${key}=${escaped_value}\" \\
"
				fi
			fi
		done <<<"$env_vars"
	fi

	# Build the exec command with proper directory handling
	# Use a custom shell command that changes directory on startup

	# Detect best architecture at launcher creation time (not runtime)
	local arch_prefix=""
	if [[ "$(sysctl -n hw.optional.arm64 2>/dev/null)" == "1" ]]; then
		# We're on Apple Silicon - use arm64 (not arm64e which Ghostty doesn't support)
		if arch -arm64 /usr/bin/true 2>/dev/null; then
			arch_prefix="arch -arm64 "
		fi
		# If it doesn't work, arch_prefix stays empty (use system default)
	fi

	# Build theme parameter if theme is specified
	local theme_param=""
	if [[ -n "$theme" ]]; then
		theme_param="    --theme=\"$theme\" \\"$'\n'
	fi

	# Build background image parameters if background is enabled
	local bg_params=""
	if [[ "$bg_enabled" == "true" ]] && [[ -f "${contents}/Resources/background.png" ]]; then
		bg_params="    --background-image=\"${contents}/Resources/background.png\" \\"$'\n'
		bg_params="${bg_params}    --background-image-opacity=\"$bg_opacity\" \\"$'\n'
		bg_params="${bg_params}    --background-image-position=\"$bg_position\" \\"$'\n'
		bg_params="${bg_params}    --background-image-fit=\"$bg_fit\" \\"$'\n'
		bg_params="${bg_params}    --background-image-margin=\"$bg_margin\" \\"$'\n'
	fi

	# Generate safe project ID from sanitized name
	local safe_project_id
	safe_project_id=$(printf '%q' "$safe_name")

	# Generate safe app name for notifications
	local safe_app_name
	safe_app_name=$(printf '%q' "$display_name")

	# Generate static exec command with predetermined architecture
	# Get the launcher app path for icon export
	local launcher_icon_path="${app_path}/Contents/Resources/icon.icns"

	cat >>"$script_path" <<EOF
# Export environment variables for Ghostty process
export GHOSTTY_PROJECT_ID=$safe_project_id
export GHOSTTY_PROJECT_PATH=\$WORKING_DIR
export GHOSTTY_APP_NAME=$safe_app_name
export GHOSTTY_LAUNCHER_BUNDLE_ID=$bundle_id
export GHOSTTY_LAUNCHER_ICON_PATH="$launcher_icon_path"
# Enable terminal-notifier for URL scheme routing (notification clicks focus correct window)
export GHOSTTY_USE_TERMINAL_NOTIFIER=1

# Launch with native working directory support and notification metadata
exec ${arch_prefix}"$TERMINAL_BIN" \\
${env_params}    --working-directory=\$WORKING_DIR \\
${theme_param}${bg_params}    "\$@"
EOF

	chmod +x "$script_path"

	# Generate config hash for change detection (include background settings)
	# Include env_vars, launcher_name, and background settings in hash to detect changes
	local config_hash
	config_hash=$(echo -n "${dir}|${display_name}|${launcher_name}|${emoji}|${theme}|${env_vars}|${bg_enabled}|${bg_opacity}|${bg_position}|${bg_fit}|${bg_margin}" | shasum -a 256 | cut -d' ' -f1)

	# Store metadata (keep display_name and launcher_name for reference)
	cat >"${contents}/.metadata" <<EOF
created=$(date -Iseconds)
dir=$dir
name=$display_name
safe_name=$safe_name
launcher_name=$launcher_name
emoji=$emoji
theme=$theme
bg_enabled=$bg_enabled
bg_opacity=$bg_opacity
bg_position=$bg_position
bg_fit=$bg_fit
bg_margin=$bg_margin
config_hash=$config_hash
EOF

	# Touch the app to update modification time
	touch "$app_path"

	# Register with macOS (skip in test mode to prevent unwanted launches)
	if [[ "${GHOSTTY_TEST_MODE:-}" != "1" ]]; then
		# Register with macOS (force registration)
		/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -f "$app_path" 2>/dev/null || true

		# Also try to rebuild launch services database for this app
		/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -R -f "$app_path" 2>/dev/null || true
	else
		log "Skipping LaunchServices registration in test mode"
	fi

	log "Created launcher at: $app_path"

	# Release lock
	cleanup_lock
	trap - EXIT INT TERM HUP
}

# List all launchers in the folder
list_launchers() {
	local count=0

	echo "=== Projects ==="

	if [[ -d "$PROJECTS_FOLDER" ]]; then
		for app in "$PROJECTS_FOLDER"/*.app; do
			if [[ -d "$app" ]]; then
				local metadata="${app}/Contents/.metadata"
				[[ ! -f "$metadata" ]] && continue

				local name
				name="$(basename "$app" .app)"

				# Show additional info from metadata
				if [[ -f "$metadata" ]]; then
					local dir
					dir=$(read_app_metadata "$app" "dir")
					local emoji
					emoji=$(read_app_metadata "$app" "emoji")
					local original_name
					original_name=$(read_app_metadata "$app" "name")

					[[ -n "$emoji" ]] && emoji=" $emoji" || emoji=""

					# Show original name if it differs from launcher name (e.g., .config vs Dot Config)
					if [[ -n "$original_name" ]] && [[ "$original_name" != "$name" ]]; then
						echo "  ‚Ä¢ $name ($original_name)$emoji ‚Üí $dir"
					else
						echo "  ‚Ä¢ $name$emoji ‚Üí $dir"
					fi
				else
					echo "  ‚Ä¢ $name"
				fi
				((count++))
			fi
		done
	fi

	if [[ $count -eq 0 ]]; then
		echo "  (no projects yet)"
		echo ""
		echo "Use 'ghostty [directory]' to add your first project."
	else
		echo ""
		echo "Total: $count project(s)"
		echo ""
		# Skip dock detection - just always show the tip since it's harmless
		if true; then
			echo "Tip: Drag '$PROJECTS_FOLDER' to your dock for quick access."
		else
			echo "Open from dock stack or Finder: $PROJECTS_FOLDER"
		fi
	fi
}

# Refresh Dock to update folder stack view
refresh_dock() {
	# Touch the Projects folder to update its modification time
	if [[ -d "$PROJECTS_FOLDER" ]]; then
		touch "$PROJECTS_FOLDER"
	fi

	# Force Dock to refresh its cache
	# Using a gentle restart that preserves Dock position
	killall Dock 2>/dev/null || true

	# Give Dock a moment to restart
	sleep 1
}

# Read metadata from app bundle
# Returns empty string if metadata doesn't exist or field not found
read_app_metadata() {
	local app_path="$1"
	local field="$2"
	local metadata_file="${app_path}/Contents/.metadata"

	if [[ -f "$metadata_file" ]]; then
		grep "^${field}=" "$metadata_file" 2>/dev/null | cut -d'=' -f2- || echo ""
	else
		echo ""
	fi
}

# Unregister app from LaunchServices
unregister_app() {
	local app_path="$1"

	if [[ -d "$app_path" ]]; then
		# Unregister from LaunchServices database
		/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -u "$app_path" 2>/dev/null || true
	fi
}

# Remove a launcher
remove_launcher() {
	local input_name="$1"
	local app_path

	# Check in folder - try exact match first
	app_path="${PROJECTS_FOLDER}/${input_name}.app"

	# If not found and input starts with dot, try "Dot X" format
	if [[ ! -d "$app_path" ]] && [[ "$input_name" =~ ^\. ]]; then
		# Convert .config to "Dot Config" format
		local name_part="${input_name:1}"
		# Capitalize first letter
		local converted_name
		converted_name="Dot $(printf "%s" "$name_part" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')"
		app_path="${PROJECTS_FOLDER}/${converted_name}.app"
	fi

	if [[ ! -d "$app_path" ]]; then
		die "Project not found: $input_name"
	fi

	# Get the actual name for display
	local display_name
	display_name=$(basename "$app_path" .app)

	# Unregister from LaunchServices before removal
	unregister_app "$app_path"

	rm -rf "$app_path"
	echo "Removed: $display_name"
	log "Removed launcher: $display_name (input: $input_name)"
}

# Remove all launchers
remove_all() {
	local count=0

	# Remove all apps in folder
	if [[ -d "$PROJECTS_FOLDER" ]]; then
		for app in "$PROJECTS_FOLDER"/*.app; do
			if [[ -d "$app" ]]; then
				# Unregister from LaunchServices before removal
				unregister_app "$app"
				rm -rf "$app"
				((count++))
			fi
		done
	fi

	# Clean up lock directory if it exists
	rm -rf "/tmp/ghostty-launcher.lock"

	if [[ $count -gt 0 ]]; then
		echo "Removed $count project(s)."
		log "Removed all $count projects"

		# Refresh Dock to clear cached icons
		echo "Refreshing Dock..."
		refresh_dock
	else
		echo "No projects to remove."
	fi
}

# Clean up orphaned launchers
# Removes launcher apps whose target directories no longer exist
# This prevents accumulation of dead launchers when projects are deleted
# Process:
#   1. Scans all .app bundles in Projects folder
#   2. Reads metadata to find target directory
#   3. Safely removes launcher if directory doesn't exist
# Returns: Number of orphaned launchers cleaned
cleanup_orphans() {
	local cleaned=0

	# Check apps in folder
	if [[ -d "$PROJECTS_FOLDER" ]]; then
		for app in "$PROJECTS_FOLDER"/*.app; do
			[[ -d "$app" ]] || continue

			local metadata="${app}/Contents/.metadata"
			if [[ -f "$metadata" ]]; then
				local dir
				dir=$(read_app_metadata "$app" "dir")
				if [[ -n "$dir" ]] && [[ ! -d "$dir" ]]; then
					# Directory no longer exists - safely remove using existing function
					local launcher_name
					launcher_name="$(basename "$app" .app)"

					# Use remove_launcher for safe removal with proper unregistration
					echo "Removing orphaned launcher: $launcher_name (was: $dir)"

					# Unregister and remove
					unregister_app "$app"
					rm -rf "$app"
					((cleaned++))
					log "Cleaned orphan: $launcher_name"
				fi
			fi
		done
	fi

	[[ $cleaned -gt 0 ]] && echo "Cleaned $cleaned orphaned launcher(s)" || true
}

# Clean up test launchers
# Safely removes launchers pointing to /tmp directories
# Used for cleaning up after tests
cleanup_test_launchers() {
	local count=0
	local verbose="${1:-}"

	[[ "$verbose" == "-v" ]] && echo "Scanning for test launchers..."

	if [[ -d "$PROJECTS_FOLDER" ]]; then
		for app in "$PROJECTS_FOLDER"/*.app; do
			[[ -d "$app" ]] || continue

			local metadata="${app}/Contents/.metadata"
			if [[ -f "$metadata" ]]; then
				local dir
				dir=$(read_app_metadata "$app" "dir")

				# Only remove if pointing to /tmp
				if [[ -n "$dir" ]] && [[ "$dir" =~ ^/tmp/ ]]; then
					local launcher_name
					launcher_name="$(basename "$app" .app)"

					[[ "$verbose" == "-v" ]] && echo "  Removing test launcher: $launcher_name ‚Üí $dir"

					# Safely remove using existing infrastructure
					unregister_app "$app"
					rm -rf "$app"
					((count++))
					log "Removed test launcher: $launcher_name"
				fi
			fi
		done
	fi

	if [[ $count -gt 0 ]]; then
		echo "Removed $count test launcher(s)"
	else
		[[ "$verbose" == "-v" ]] && echo "No test launchers found"
	fi

	return 0
}

# Clean up old launchers for the same project with different names
# When a project's name changes in VSCode settings, remove the old launcher
# Parameters:
#   $1 - project_dir: The directory of the project
#   $2 - new_launcher_name: The new launcher filename (e.g., "dot-config" for ".config")
#   $3 - display_name: The display name (e.g., ".config")
# Process:
#   1. Scans all launchers in Projects folder
#   2. Finds launchers pointing to the same directory
#   3. Removes launchers that don't match the new name
#   4. Also removes old dot-prefixed launchers (e.g., .config.app)
cleanup_old_launchers_for_project() {
	local project_dir="$1"
	local new_launcher_name="$2"
	local display_name="${3:-$2}"
	local cleaned=0

	if [[ -d "$PROJECTS_FOLDER" ]]; then
		# Check both regular and dot-prefixed apps (handle glob expansion safely)
		shopt -s nullglob # Make globs expand to nothing if no matches
		for app in "$PROJECTS_FOLDER"/*.app "$PROJECTS_FOLDER"/.*.app; do
			[[ -d "$app" ]] || continue

			local app_name
			app_name="$(basename "$app" .app)"

			# Skip if this is the current/new launcher
			if [[ "$app_name" == "$new_launcher_name" ]]; then
				continue
			fi

			# Check if this launcher points to the same project directory
			local stored_dir
			stored_dir=$(read_app_metadata "$app" "dir")

			if [[ "$stored_dir" == "$project_dir" ]]; then
				# This launcher points to the same directory but has a different name
				# It's an old launcher that should be removed
				log "Removing old launcher '$app_name' for project in $project_dir (new name: $new_launcher_name)"

				# Unregister from LaunchServices before removal
				unregister_app "$app"

				# Remove the old launcher
				rm -rf "$app"
				((cleaned++))
			fi
		done
		shopt -u nullglob # Reset nullglob to default
	fi

	[[ $cleaned -gt 0 ]] && log "Removed $cleaned old launcher(s) for project: $display_name" || true
}

# Show help
show_help() {
	cat <<EOF
Ghostty Dock Launcher v${VERSION}

Simple project terminals in a folder stack.

USAGE:
    ghostty [OPTIONS] [DIRECTORY]

OPTIONS:
    -h, --help       Show this help message
    -v, --version    Show version number

COMMANDS:
    ghostty [DIR]        Add project terminal (default: current directory)
    ghostty list         List all projects
    ghostty remove NAME  Remove a project
    ghostty remove-all   Remove all projects
    ghostty cleanup-test Clean up test launchers (from /tmp)
    ghostty cleanup-dock Clean up Dock cache and orphaned icons
    ghostty set-icon     Set/refresh Projects folder icon
    ghostty help         Show this help

INTERNAL/DEBUG:
    --which-binary   Show detected Ghostty binary path
    --debug DIR      Run with debug tracing enabled

HOW IT WORKS:
    1. Run 'ghostty' in any project directory
    2. Creates launcher in: /Applications/Projects/
    3. Drag that folder to your dock (one-time setup)
    4. Click the stack to see all projects in a grid
    5. Click any project to open its terminal

VSCode Integration:
    Add to your .vscode/settings.json:
    {
        "commandCentral.project.icon": "üöÄ",    // Emoji for dock icon
        "commandCentral.project.name": "My App", // Display name
        "commandCentral.terminal.theme": "nord"  // Terminal theme
    }

Environment Variables:
    TERMINAL_APP  Path to terminal app (default: /Applications/Ghostty.app)
    TERMINAL_BIN  Path to terminal binary (auto-detected if not set)

Examples:
    cd ~/my-project && ghostty    # Add current project
    ghostty ~/another-project     # Add specific project
    ghostty list                  # See all projects
    ghostty remove "My App"       # Remove a project
    
    # Use a local development build
    export TERMINAL_APP="/Users/$USER/ghostty/macos/build/ReleaseLocal/Ghostty.app"
    ghostty ~/my-project

That's it. Native macOS folder stack for all your terminals.
EOF
}

# Main
main() {
	# Check if running in test mode
	if [[ "${GHOSTTY_TEST_MODE:-}" == "1" ]]; then
		log "Test mode enabled - skipping UI operations"
		[[ "${GHOSTTY_TEST_QUIET:-}" != "1" ]] && echo "‚úì Test mode enabled (skipping 'open' commands)"
	fi

	check_requirements

	# Clean up orphans periodically
	cleanup_orphans

	# Parse command
	case "${1:-}" in
		-h | --help | help)
			show_help
			exit 0
			;;
		list)
			list_launchers
			exit 0
			;;
		cleanup-test)
			echo "Cleaning up test launchers..."
			cleanup_test_launchers "${2:-}"
			# Also clean up test directories
			echo "Cleaning up test directories..."
			rm -rf /tmp/ghostty-test-* /tmp/test-*json* /tmp/test-project* 2>/dev/null || true
			echo "Test cleanup complete."
			exit 0
			;;
		cleanup-dock)
			echo "Cleaning up Dock cache and orphaned launchers..."
			cleanup_orphans
			refresh_dock
			echo "Dock cleanup complete."
			exit 0
			;;
		set-icon)
			echo "Setting Projects folder icon..."
			ensure_folder_exists
			set_projects_folder_icon "$PROJECTS_FOLDER_EMOJI"
			echo "‚úÖ Icon updated"
			exit 0
			;;
		remove)
			[[ -z "${2:-}" ]] && die "Usage: ghostty remove NAME"
			remove_launcher "$2"
			exit 0
			;;
		remove-all)
			remove_all
			exit 0
			;;
		-v | --version)
			echo "v${VERSION}"
			exit 0
			;;
		--which-binary)
			# Show which Ghostty binary will be used (for just which-ghostty)
			echo "$TERMINAL_BIN"
			echo "Source: $TERMINAL_APP_SOURCE"
			exit 0
			;;
		--which-binary-info)
			# Show binary info for just info command
			echo "Ghostty binary: $TERMINAL_BIN"
			echo "Detection: $TERMINAL_APP_SOURCE"
			exit 0
			;;
		--debug)
			# Debug mode
			set -x
			smart_open "${2:-}"
			exit 0
			;;
		-*)
			# Unknown flag - show helpful error
			echo "Error: Unknown option: $1" >&2
			echo "Run 'ghostty --help' for usage information." >&2
			exit 2
			;;
		*)
			# Default action: smart open
			smart_open "${1:-}"
			;;
	esac
}

# Run if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
